// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ProfileService.h"
#include "Buffer.h"
#include "Cache.h"
#include "Database.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <iostream>
#include <thread>
#include <chrono>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

//static long t1;
//static long t2;
//static long t3;

class ProfileServiceHandler : virtual public ProfileServiceIf {
private:
    Database *database;
    Cache *cache;
    Buffer *buffer;
public:
    ProfileServiceHandler() {
        database = Database::getDatabase("LevelDB");
        cache = Cache::getCache("Memcached");
        buffer = Buffer::getBuffer("HashMap");
    }

    void getData(GetResult &_return, const std::string &key) {
        std::string result;
        
        GetResult bufferResult, cacheResult, dbResult;
        bufferResult = buffer->getData(key);
        if (bufferResult.isNull) {    // Not exist in buffer
            cacheResult = cache->getData(key);
            if (cacheResult.isNull) {    // Not exist in cache
                dbResult = database->getData(key);
                if (!dbResult.isNull) {    // Hit in database, then put result to cache and buffer
                    cache->setData(key, result);
                    buffer->setData(key, result);
                }
                _return = dbResult;
            }
            else {
                buffer->setData(key, result);   // Hit in cache, then put result to buffer
            }

            _return = cacheResult;
        }

        _return = bufferResult;
    }

    bool setData(const std::string &key, const std::string &value) {
        bool r1 = database->setData(key, value);
        bool r2 = cache->setData(key, value);
        bool r3 = buffer->setData(key, value);

        return r1 && r2 && r3;
    }

//    bool setData(const std::string &key, const std::string &value) {
//        auto start = std::chrono::steady_clock::now();
//        bool r1 = database->setData(key, value);
//        t1 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
//
//        start = std::chrono::steady_clock::now();
//        bool r2 = cache->setData(key, value);
//        t2 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
//
//        start = std::chrono::steady_clock::now();
//        bool r3 = buffer->setData(key, value);
//        t2 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
//
//        if (key == "ID100000") {
//            std::cout << "Database access time: " << t1/1000000 << std::endl << "Cache access time: " << t2/1000000 << std::endl << "Buffer access time: " << t3/1000000 << std::endl;
//        }
//        return true;
//    }

    bool removeData(const std::string &key) {
        // Delete key in cache and database
        bool r1 = database->removeData(key);
        bool r2 = cache->removeData(key);
        bool r3 = buffer->removeData(key);

        return r1 && r2 && r3;
    }
};

int main(int argc, char **argv) {
    // Server setup parameters
    int port = 7999;
    boost::shared_ptr<ProfileServiceHandler> handler(new ProfileServiceHandler());
    boost::shared_ptr<TProcessor> processor(new ProfileServiceProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    // Set up worker-thread manager
    int hw_threads = std::thread::hardware_concurrency();
    // int io_threads = hw_threads / 2 + 1;
    int worker_threads = int(hw_threads * 1.5) + 1;
    boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager((size_t) worker_threads);
    boost::shared_ptr<PlatformThreadFactory> threadFactory(new PlatformThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    // TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

//     TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);

    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    // server.setNumIOThreads(io_threads);

    server.serve();

    return 0;
}
