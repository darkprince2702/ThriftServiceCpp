// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ProfileService.h"
#include "Buffer.h"
#include "Cache.h"
#include "Database.h"
#include "DumpFile.h"
#include "LogFile.h"
#include "SaveFile.h"
#include "Timer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSimpleFileTransport.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <iostream>
#include <thread>
#include <chrono>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace profileservice;
//static long t1;
//static long t2;
//static long t3;

class ProfileServiceHandler : virtual public ProfileServiceIf {
private:
    boost::shared_ptr<Database> database;
    boost::shared_ptr<Cache> cache;
    boost::shared_ptr<Buffer> buffer;
    boost::shared_ptr<SaveFile> saveFile;
    boost::shared_ptr<DumpFile> dumpFile;
    boost::shared_ptr<LogFile> logFile;
    boost::shared_ptr<Timer> timer;
public:

    ProfileServiceHandler() {
        // Initialize variable
        database.reset(Database::getInstance());
        cache.reset(Cache::getCache("Memcached"));
        buffer.reset(Buffer::getBuffer("HashMap"));
        saveFile.reset(SaveFile::getInstance());
        dumpFile.reset(DumpFile::getInstance());
        logFile.reset(LogFile::getInstance());
        timer.reset(Timer::getInstance());
        // Load data from dump file and log file
        dumpFile->load();
        logFile->load();
//        timer->run();
    }

    void getData(GetResult &_return, const std::string &key) {
        GetResult bufferResult, cacheResult, dbResult;
        bufferResult = buffer->getData(key);
        if (bufferResult.isNull) { // Not exist in buffer
            cacheResult = cache->getData(key);
            if (cacheResult.isNull) { // Not exist in cache
                dbResult = database->getData(key);
                if (!dbResult.isNull) { // Hit in database, then put result to cache and buffer
                    cache->setData(key, dbResult.value);
                    buffer->setData(key, dbResult.value);
                }
                _return = dbResult;
            } else {

                buffer->setData(key, cacheResult.value); // Hit in cache, then put result to buffer
                _return = cacheResult;
            }
        } else {
            _return = bufferResult;
        }
    }

    bool setData(const std::string &key, const std::string &value) {
        bool r1 = database->setData(key, value);
        bool r2 = cache->setData(key, value);
        bool r3 = buffer->setData(key, value);

        if (r3) {
            logFile->addLog("setData(" + key + "," + value + ")");
        }

        return r1 && r2 && r3;
    }

    //    bool setData(const std::string &key, const std::string &value) {
    //        auto start = std::chrono::steady_clock::now();
    //        bool r1 = database->setData(key, value);
    //        t1 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
    //
    //        start = std::chrono::steady_clock::now();
    //        bool r2 = cache->setData(key, value);
    //        t2 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
    //
    //        start = std::chrono::steady_clock::now();
    //        bool r3 = buffer->setData(key, value);
    //        t2 += std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start).count();
    //
    //        if (key == "ID100000") {
    //            std::cout << "Database access time: " << t1/1000000 << std::endl << "Cache access time: " << t2/1000000 << std::endl << "Buffer access time: " << t3/1000000 << std::endl;
    //        }
    //        return true;
    //    }

    bool removeData(const std::string &key) {
        // Delete key in cache and database
        bool r1 = database->removeData(key);
        bool r2 = cache->removeData(key);
        bool r3 = buffer->removeData(key);

        if (r3) {
            logFile->addLog("removeData(" + key + ")");
        }

        return r1 && r2 && r3;
    }
};

int main(int argc, char **argv) {
    // Server setup parameters
    int port = 7999;
    boost::shared_ptr<ProfileServiceHandler> handler(new ProfileServiceHandler());
    boost::shared_ptr<TProcessor> processor(new ProfileServiceProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    // Set up worker-thread manager
    int hw_threads = std::thread::hardware_concurrency();
    // int io_threads = hw_threads / 2 + 1;
    int worker_threads = int(hw_threads * 1.5) + 1;
    boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager((size_t) worker_threads);
    boost::shared_ptr<PlatformThreadFactory> threadFactory(new PlatformThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    // TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

    //     TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);

    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    // server.setNumIOThreads(io_threads);

    server.serve();

    return 0;
}
